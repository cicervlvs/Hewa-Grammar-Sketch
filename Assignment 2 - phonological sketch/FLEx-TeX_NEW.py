"""
Copyright 2012 Gregory Finley

Copyright 2018 Christopher Weedall

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

# FLEx-TeX
# for configured FLEx dictionary with sorting and Tcl/Tk GUI
# Greg Finley, 2012-2013

# Updated for FLEx 8+
# Christopher Weedall, 2018

import sys, os, shutil
import xml.etree.ElementTree as ET
import datetime
import string
import codecs

# import tkinter
# from tkinter import *
# from tkinter import ttk
import tkinter as tk
from tkinter import ttk

import tkinter.filedialog as filedialog

makedic = False

class Application(tkinter.Frame):

	def createWidgets(self):

		self.msg = tkinter.Message(self)
		self.msg["text"] = """
FLEx-TeX converts your FLEx .lift (XML) file into two files.  The first defines all the commands created and has some \\usepackage{} statements.  The second includes all your FLEx entries, wrapped in those commands to allow for formatting.

STEP 1:
Locate your .LIFT (XML) file from FLEx

STEP 2:
A new folder with the date and time is created
(format: YYYY-MM-DD_HHmm)

Inside the folder:
	FLExentries.tex (use \input{FLExentries.tex in preamble)
	FLExcommands.tex (use \input{FLExentries.tex} in document)
		"""
		self.msg.config(width=400)
		self.msg.pack()

		'''self.sort = tkinter.Checkbutton(self)
		self.sortbox = tkinter.IntVar()
		self.sort["variable"] = self.sortbox
		self.sort["text"] = "Sort entries alphabetically?"
		self.sort.select()
		self.sort.pack()'''

		self.go = tkinter.Button(self)
		self.go["text"] = "Locate files"
		self.go["command"] = self.letsgo
		self.go.pack()

	def letsgo(self):
		self.makedic=True
		self.quit()

	def __init__(self, master=None):
		tkinter.Frame.__init__(self, master)
		self.master.title("FLEx-TeX")
		self.pack()
		self.createWidgets()
		self.makedic = False

app = Application()
app.mainloop()
if not app.makedic: os._exit(0)

xmlfilemsg = "XML file from FLEx?"
xmlfile = filedialog.askopenfilename(title = xmlfilemsg)

if not xmlfile: os._exit(0)

alphafilemsg = "Alphabet file? Hit 'Cancel' to use English alphabetization."
alphafile = False#filedialog.askopenfilename(title = alphafilemsg)

defsfilemsg = "Custom command definitions? Hit 'Cancel' to use the file generated by FLEx-TeX."
defsfileusr = False#filedialog.askopenfilename(title = defsfilemsg)

mainfilemsg = "LaTeX main file? Hit 'Cancel' to supply the file manually later."
mainfile = False#filedialog.askopenfilename(title = mainfilemsg)

app.master.destroy()


# Once the applet closes, make the dictionary

now = datetime.datetime.now()

# ~~~~~~~~~
# Functions
# ~~~~~~~~~

# Here is the key function (works with Python 3)
def gregSortKey(word, alphabet):
    i = 0
    score = ""

    while i < len(word) :
        # check for digraphs (or trigraphs)
        char = getMaximalLetter(word[i:], alphabet)
        # And if we did use a long letter, be sure to update our counter

        if not char in alphabet : char = word[i]

        i += len(char) - 1

        if not char in alphabet: char = 'default'

        score += chr(alphabet[char])
        score += ""
        i += 1
# And return the final score
    return score


# Finds the maximal letter in a string, beginning at a specified index.
# Good for digraphs, trigraphs, or larger (e.g., combining characters!)
def getMaximalLetter(word, alphabet) :
	substr = ''
	n = 0
	letter = word[n]
	while n < len(word) :
		substr += word[n]
		if substr in alphabet :
			letter = substr
		n += 1
	return letter

# To strip out pesky \n and \r characters

def fixline(line) :
    line = line.replace("\r",'')
    line = line.replace("\n",'')
    return line

def fixtag(tag) :
	tag = tag.replace("_","")      # LaTeX doesn't like these characters
	tag = tag.replace("-","")
	tag = tag.replace(".","")
	tag = tag.replace("*","")
	tag = tag.replace(" ","")
	# And this will replace numbers with letters
	for digit in string.digits:
		tag = tag.replace(digit, string.ascii_uppercase[int(digit)])
	return tag

# In case there are cross-references

def subscript_final_numbers(txt):
    numerals = []
    for a in range(10): numerals.append(str(a))

    if len(txt) < 2 or txt[0] in numerals: return txt

    if txt[-1] in numerals:
        if txt[-2] in numerals:
            txt = txt[0:-2] + "\\textsubscript{" + txt[-2:] + "}"
        else:
            txt = txt[0:-1] + "\\textsubscript{" + txt[-1:] + "}"

    return txt

# ~~~~~~~~~~~~~~
# Variable setup
# ~~~~~~~~~~~~~~

allTags = []
thispath = os.path.dirname(sys.argv[0])
defaultxml = "xmlfile.xml"
entriesfilename = "FLExentries.tex"
defsfilename = "FLExcommands.tex"
defsfilealtname = "all_field_types_blank.tex"
outfilename = "dictionary.tex"

# ~~~~~~~~~~~~~~~
# File operations
# ~~~~~~~~~~~~~~~
newpath = str(now.year) + "-" + str(now.month).zfill(2) + "-" + str(now.day).zfill(2) + "_" + str(now.hour).zfill(2) + str(now.minute).zfill(2)
newpath = os.path.join(thispath,newpath)
defaultpath = os.path.join(thispath,"default")

if not os.path.exists(newpath):
    os.makedirs(newpath)
outfile = codecs.open(os.path.join(newpath, entriesfilename), 'w', 'utf-8')
defsfile = codecs.open(os.path.join(newpath, defsfilename),'w', 'utf-8')
try:
    shutil.copyfile(mainfile, os.path.join(newpath, os.path.split(mainfile)[-1]))
except:
    # Change this to a GUI message
    print("No main file found. You'll need to supply a LaTeX file with the \\input{} statement later.")

	
# Alphabet file
if alphafile:
    alphaData = open(alphafile,'r')

    i = 1
    alphabet = {'default':0}   # The alphabet itself
    headings = {}   # This dict contains what will be written for headings
    keyName = ""    # Temporary variable (see below)

    for line in alphaData:
        line = fixline(line)

        bothHalves = line.split("\t")
        try:
            keyName = bothHalves[0]
            characters = bothHalves[1]
        except:
            print("Alphabet file not configured properly.")

        for character in characters.split() :
            alphabet[character] = i
        headings[i] = keyName
        i += 1
    alphaData.close()


# Use default English alphabet if no file specified
else:
    alphabet = {'default':0}
    headings = {}
    for i in range(0, 26):
        alphabet[string.ascii_uppercase[i]] = i
        alphabet[string.ascii_lowercase[i]] = i
        headings[i] = string.ascii_uppercase[i]


# Get the XML
try:
    tree = ET.parse(xmlfile)
except:
    # Print a little graphical message here maybe?
    print("No dictionary file found. Exiting.")
    os._exit(0)

root = tree.getroot()

# Set up the master list and counter

masterlist = []
mlcount = 0

senselist = []

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create list of entries using XML input
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

for entry in root.findall('entry'):
	
	if 'id' in entry.attrib:
		thisid = entry.attrib['id']
		masterlist.append(['', '\\FLExentry{%\n'])
		if not allTags:
			allTags.append(['FLExentry',['Entry details']])

		txt = ''
		forms = ''
		morphtype = ''
		extratraits = ''
		
		#############################################################
		#LEXICAL-UNIT
		lexunit = entry.find('lexical-unit')
		formcount = 0
		for form in lexunit.findall('form'):
			if formcount == 0:
				txt += '\t\\FLExheadword{' + form.find('text').text + '}\\quad%\n'
				masterlist[mlcount][0] = form.find('text').text
				if ['FLExheadwordformat', ['Headword']] not in allTags:
					allTags.append(['FLExheadwordformat', ['Headword']])
				if ['FLExheadword', ['Headword']] not in allTags:
					allTags.append(['FLExheadword', ['Headword']])
			forms += '\t\\FLExform{' + form.find('text').text + '}{' + form.attrib['lang'] + '},\\qquad %\n'

			if ['FLExformformat', ['Lexical form']] not in allTags:
				allTags.append(['FLExformformat', ['Lexical form']])
			if ['FLExformandWSsep', []] not in allTags:
				allTags.append(['FLExformandWSsep', []])	
			if ['FLExformWSwrapper', ['writing system (language)']] not in allTags:
				allTags.append(['FLExformWSwrapper', ['writing system (language)']])
			if ['FLExformWSformat', ['writing system (language)']] not in allTags:
				allTags.append(['FLExformWSformat', ['writing system (language)']])
			if ['FLExform', ['Lexical form', 'writing system (language)']] not in allTags:
				allTags.append(['FLExform', ['Lexical form', 'writing system (language)']])
			formcount += 1
		#############################################################
		#TRAIT
		for trait in entry.findall('trait'):
			traitname = trait.attrib['name']
			tag = fixtag(traitname)
			if traitname == 'morph-type':
				morphtype += '\t\\FLEx'+ tag +'{' + trait.attrib['value'] + '}%\n'
				if ['FLEx'+tag, ['Morphological type']] not in allTags:
					allTags.append(['FLEx'+tag, ['Morphological type']])
			else:
				extratraits += '\t\\FLEx' + tag + '{' + trait.attrib['value'] + '}\\\\%\n'
				if ['FLEx'+tag, [tag]] not in allTags:
					allTags.append(['FLEx'+tag, [tag]])
		#############################################################
		#PRONUNCIATION
		syllable = ''
		tone = ''
		plocation = ''
		for pronounce in entry.findall('pronunciation'):
			txt += '\t\\FLExpronunciation{' + pronounce.find('form').find('text').text + '}\\quad%\n'
			if ['FLExpronunciation', ['Pronunciation']] not in allTags:
				allTags.append(['FLExpronunciation', ['Pronunciation']])
			if ['FLExpronouncewrapper', ['Pronunciation']] not in allTags:
				allTags.append(['FLExpronouncewrapper', ['Pronunciation']])
			if ['FLExpronounceformat', ['Pronunciation']] not in allTags:
				allTags.append(['FLExpronounceformat', ['Pronunciation']])

			for field in pronounce.findall('field'):
				if field.attrib['type'] == 'cv-pattern':
					syllable = '\t\\FLExsyllable{' + field.find('form').find('text').text + '}%\n'
					if ['FLExsyllable', ['CV Pattern']] not in allTags:
						allTags.append(['FLExsyllable', ['CV Pattern']])
				elif field.attrib['type'] == 'tone':
					tone = '\t\\FLExtone{' + field.find('form').find('text').text.replace(' ','~') + '}%\n'
					if ['FLExtone', ['Tone']] not in allTags:
						allTags.append(['FLExtone', ['Tone']])
				elif field.attrib['type'] == 'location':
					plocation = '\t\\FLExpronouncelocation{' + field.find('form').find('text').text + '}%\n'
					if ['FLExpronouncelocation', ['Location']] not in allTags:
						allTags.append(['FLExpronouncelocation', ['Location']])
			txt += '' if plocation == '' else plocation
		#############################################################
		#Add out of order items (i.e. morph-type BEFORE forms)
		txt += morphtype + "\t\\\\%\n"
		txt += '' if syllable == '' else syllable
		txt += '' if syllable == '' or tone == '' else '\t\\quad%\n'
		txt += '' if tone == '' else tone
		txt = txt + "\t\\\\%\n"
		txt += forms[:-10] + "%\n\t\\\\%\n"
		#############################################################
		#COMPLEX FORM
		componentlexemelatex = ''
		componentlexemes = []
		componentlexemeformtypesSTR = ''
		componentlexemeformtypes = []
		for componentlexeme in entry.findall('relation'):
			#ADD the component from (from the reference tag)
			componentlexemes.append(componentlexeme.attrib['ref'].split('_')[0])

			for componentlexemetrait in componentlexeme.findall('trait'):
				if componentlexemetrait.attrib['name'] not in ['is-primary', 'hide-minor-entry']:
					componentlexemeformtypes.append(componentlexemetrait.attrib['value'])
			
			tempList = []
			tempStr = ''
			for formtype in componentlexemeformtypes:
				if formtype not in tempList:
					tempList.append(formtype)
			for uniqueformtype in tempList:
				if tempStr != '':
					tempStr += '\\FLExcomponenttypesep{}'
					if ['FLExcomponenttypesep', []] not in allTags:
						allTags.append(['FLExcomponenttypesep', []])
				tempStr += uniqueformtype
			componentlexemeformtypes = []
			for index in range(len(componentlexemes)):
				componentlexemeformtypes.append(tempStr)

		componentlexemedict = dict()
		if componentlexemes:
			for index,formtype in enumerate(componentlexemeformtypes):
				if formtype not in componentlexemedict:
					componentlexemedict[formtype] = [componentlexemes[index]]
				else:
					componentlexemedict[formtype].append(componentlexemes[index])
			for theType, theForm in componentlexemedict.items():
				componentlexemelatex += '\t\\FLExcomponent{'+ theType +'}{'
				for theFormIndex, theFormItem in enumerate(theForm):
					if theFormIndex < len(theForm)-1:
						componentlexemelatex += theFormItem + '\\FLExcomponentformindex{' + str(theFormIndex) + '}\\FLExcomponentformsep{}'
				componentlexemelatex += '}%\n\t\\\\%\n'
				
			if ['FLExcomponenttypewrapper', ['Component type']] not in allTags:
				allTags.append(['FLExcomponenttypewrapper', ['Component type']])
			if ['FLExcomponenttypeformat', ['Component type']] not in allTags:
				allTags.append(['FLExcomponenttypeformat', ['Component type']])
			if ['FLExcomponentformwrapper', ['Component form(s)']] not in allTags:
				allTags.append(['FLExcomponentformwrapper', ['Component form(s)']])
			if ['FLExcomponenformformat', ['Component form(s)']] not in allTags:
				allTags.append(['FLExcomponenformformat', ['Component form(s)']])
			if ['FLExcomponentformindex', ['Component form index']] not in allTags:
				allTags.append(['FLExcomponentformindex', ['Component form index']])
			if ['FLExcomponenttypeformsep', []] not in allTags:
				allTags.append(['FLExcomponenttypeformsep', []])	
			if ['FLExcomponentformsep', []] not in allTags:
				allTags.append(['FLExcomponentformsep', []])
			if ['FLExcomponent', ['Component type', 'Component form(s)']] not in allTags:
				allTags.append(['FLExcomponent', ['Component type', 'Component form(s)']])

		txt += componentlexemelatex
		#############################################################
		#SENSE
		senses = entry.findall('sense')
		numsenses = len(senses)
		
		if numsenses > 1:
			txt = txt[:-4] + '%\n\t\\FLExsenses{%\n'
			if ['FLExsenses', ['Senses']] not in allTags:
				allTags.append(['FLExsenses', ['Senses']])
		for sense in entry.findall('sense'):
			if numsenses > 1:
				txt += '\t\t\\FLExsenseitem{%\n'
				if ['FLExsenseitem', ['Sense']] not in allTags:
					allTags.append(['FLExsenseitem', ['Sense']])
			else:
				txt += '\t\\FLExsense{%\n'
				if ['FLExsense', ['Sense']] not in allTags:
					allTags.append(['FLExsense', ['Sense']])
			if sense.find('grammatical-info') != None:
				if numsenses > 1:
					txt += '\t'
				txt += '\t\t\\FLExgrammaticalinfo{' + sense.find('grammatical-info').attrib['value'] + '}%\n'
				if ['FLExgrammaticalinfo', ['Grammatical info']] not in allTags:
					allTags.append(['FLExgrammaticalinfo', ['Grammatical info']])
			if sense.find('definition') != None:
				for definition in sense.find('definition').findall('form'):
					if numsenses > 1:
						txt += '\t'
					txt += '\t\t\\FLExdefinition{' + definition.find('text').text + '}{' + definition.attrib['lang'] + '}\n'
				if ['FLExdefinitionWSwrapper', ['Definition language']] not in allTags:
					allTags.append(['FLExdefinitionWSwrapper', ['Definition language']])
				if ['FLExdefinitionWSformat', ['Definition language']] not in allTags:
					allTags.append(['FLExdefinitionWSformat', ['Definition language']])
				if ['FLExdefinition', ['Definition', 'Definition language']] not in allTags:
					allTags.append(['FLExdefinition', ['Definition', 'Definition language']])
			elif sense.find('gloss') != None:
				if numsenses > 1:
					txt += '\t'
				txt += '\t\t\\FLExgloss{' + sense.find('gloss').find('text').text + '}{' + sense.find('gloss').attrib['lang'] + '}%\n'
				if ['FLExgloss', ['Gloss', 'Gloss language']] not in allTags:
					allTags.append(['FLExgloss', ['Gloss', 'Gloss language']])
				if ['FLExglossWSwrapper', ['Gloss language']] not in allTags:
					allTags.append(['FLExglossWSwrapper', ['Gloss language']])
				if ['FLExglossWSformat', ['Gloss language']] not in allTags:
					allTags.append(['FLExglossWSformat', ['Gloss language']])
			if numsenses > 1:
				txt += '\t'
			txt += '\t}%\n'
		if numsenses > 1:
			txt += '\t}%\n'
		else:
			txt = txt[:-2] + '\\\\%\n'
		#############################################################
		#END of the entry
		#masterlist[mlcount][1] += txt + extratraits + '}%\n\n'
		masterlist[mlcount][1] += txt + '}%\n\n'
		mlcount += 1
	else:
		print("Not an entry...? ", entry.attrib)

# Now sort all the entries
'''if app.sortbox.get() :
    if alphafile:
        masterlist.sort(key=(lambda x: gregSortKey(x[0], alphabet)))
    else:
        masterlist.sort(key=(lambda x: x[0].lower()))'''
if alphafile:
	masterlist.sort(key=(lambda x: gregSortKey(x[0], alphabet)))
else:
	masterlist.sort(key=(lambda x: x[0].lower()))



defsfile.write('\n\n')

defsfile.write('\\usepackage[T1]{fontenc}\n')
defsfile.write('%======================\n')
defsfile.write('%======================\n')
defsfile.write('%%% WARNING !!!\n')
defsfile.write('%\n')
defsfile.write('%%% You *MUST* use XeLaTeX or LuaLaTeX\n')
defsfile.write('%%% This is necessary for using Unicode characters directly within the document\n')
defsfile.write('%%% Your alternatives are that \\charissil (the recommended font) does nothing as a fallback in pdfLaTex\n')
defsfile.write('%%% or to use the TIPA package.  The TIPA package is legacy and if you want to convert the\n')
defsfile.write('%%% Unicode characters from Fieldworks Language Explorer (FLEx), then that is your burden.\n')
defsfile.write('%%% That conversion is beyond my time or interest and very difficult to read with the .tex\n')
defsfile.write('%%% document anyway.  Don\'t complain to me or anyone else if you decide not to use either\n')
defsfile.write('%%% XeLaTeX or LuaLaTeX.\n')
defsfile.write('%======================\n')
defsfile.write('%======================\n')
defsfile.write('\\usepackage{ifxetex}\n')
defsfile.write('\\ifxetex\n')
defsfile.write('\t\\usepackage{fontspec}\n')
defsfile.write('\t\\newfontfamily\\charissil[Ligatures={NoCommon},\n')
defsfile.write('\t\t\t\t\t\t\t\tRawFeature=+onum,]{Charis SIL}\n')
defsfile.write('\\else\n')
defsfile.write('\t\\newcommand{\\charissil}[1]{#1}\n')
defsfile.write('\\fi\n')
defsfile.write('%======================\n')
defsfile.write('%======================\n\n')
defsfile.write('\\usepackage{enumitem}\n\n')


# Now it's time to write the output file.
curletter = 'default'
printedunsorted = False
for entry in masterlist:
	thisfirstletter = getMaximalLetter(entry[0],alphabet)

	if thisfirstletter in alphabet and curletter in alphabet and thisfirstletter != curletter:
		curletter = thisfirstletter
		outfile.write('\\FLExNewLetter{' + headings[alphabet[curletter]] + '}\n\n')
	elif not printedunsorted:
		outfile.write('\\FLExNewLetter{Unsorted}\n\n')
		printedunsorted = True

	outfile.write(entry[1])


# Write the other file with all the LaTeX \newcommands
defsfile.write('\\newcommand{\\FLExNewLetter}[1]\n\t{\\section*{\\makebox[0pt][l]{\\rule[-0.35\\baselineskip]{\\linewidth}{0.75mm}}#1}\\noindent\\\\} %% Letter heading\n\n')
tagoutput = ''
for tagindex, tag in enumerate(allTags):
	tagoutput = '\\newcommand{\\' + tag[0] + '}'
	if not tag[1]:
		if allTags[tagindex][0] == 'FLExformandWSsep':
			tagoutput += '{~}%% Form and writing system separator'
		if allTags[tagindex][0] == 'FLExcomponentformsep':
			tagoutput += '{, }%% Component forms separator'
		elif allTags[tagindex][0] == 'FLExcomponenttypesep':
			tagoutput += '{, }%% Component types separator'
		elif allTags[tagindex][0] == 'FLExcomponenttypeformsep':
			tagoutput += '{\quad}%% Separator between Component type(s) and Component form(s)'	
	else:
		tagoutput += '[' + str(len(tag[1])) + ']\n\t{'
		for index, arg in enumerate(tag[1]):
			if index > 0:
				tagoutput += ' '
			if index < len(tag[1])-1:
				#=================================================================
				# If more than one argument, loop through all BUT last one
				#=================================================================
				if allTags[tagindex][0] == 'FLExheadwordformat':
					tagoutput += '\\textbf{'
				elif allTags[tagindex][0] == 'FLExheadwordWSformat':
					tagoutput += '\\textit{'
				elif allTags[tagindex][0] == 'FLExpronouncewrapper':
					tagoutput += '{/'
				elif allTags[tagindex][0] == 'FLExpronounceformat':
					tagoutput += '\\charissil{'
				elif allTags[tagindex][0] == 'FLExform':
					tagoutput += '\\FLExformformat{'
				elif allTags[tagindex][0] == 'FLExcomponent':
					tagoutput += '\\FLExcomponenttypewrapper{\\FLExcomponenttypeformat{'	
				elif allTags[tagindex][0] == 'FLExsenses':
					tagoutput += '\\begin{enumerate}'
				elif allTags[tagindex][0] == 'FLExsenseitem':
					tagoutput += '\\item '#extra space is necessary!!
				
				tagoutput += '#' + str(index+1)
				
				if allTags[tagindex][0] == 'FLExheadwordformat' \
					or allTags[tagindex][0] == 'FLExheadwordWSformat' \
					or allTags[tagindex][0] == 'FLExpronounceformat' \
					or allTags[tagindex][0] == 'FLExform':
					tagoutput += '}'
				elif allTags[tagindex][0] == 'FLExform':
					tagoutput += '~}'
				elif allTags[tagindex][0] == 'FLExpronouncewrapper':
					tagoutput += '/}'
				elif allTags[tagindex][0] == 'FLExcomponent':
					tagoutput += '}}'
				elif allTags[tagindex][0] == 'FLExsenses':
					tagoutput += '\\end{enumerate}~\\par'
				tagoutput += '%% ' + arg + '\n\t'
				
				
				if allTags[tagindex][0] == 'FLExform':
					tagoutput += '\\FLExformandWSsep{}%\n\t'
				#Use a special check (in LaTeX) - only use separator macro IF second argument is not empty
				elif allTags[tagindex][0] == 'FLExcomponent':
					tagoutput += '\t\\ifx&#2&%\n\t\t\t%No need for separator\n\t\t\\else\n\t\t\t\\FLExcomponenttypeformsep{}%\n\t\t\\fi%\n\t'
				#=================================================================

		#=================================================================
		## Last argument (OR only argument
		#=================================================================
		if allTags[tagindex][0] == 'FLExentry':
			tagoutput += '\\hangindent=1.5cm\n\t\\hangafter=1\n\t'
		elif allTags[tagindex][0] == 'FLExheadword':
			tagoutput += '\\FLExheadwordformat{'
		elif allTags[tagindex][0] == 'FLExheadwordformat':
			tagoutput += '\\textbf{\large '
		elif allTags[tagindex][0] == 'FLExheadwordWSformat' \
				or allTags[tagindex][0] == 'FLExformWSformat' \
				or allTags[tagindex][0] == 'FLExglossWSformat' \
				or allTags[tagindex][0] == 'FLExdefinitionWSformat':
			tagoutput += '\\textit{'
		elif allTags[tagindex][0] == 'FLExpronunciation':
			tagoutput += '\\FLExpronouncewrapper{\\FLExpronounceformat{'
		elif allTags[tagindex][0] == 'FLExpronouncewrapper':
			tagoutput += '{/'
		elif allTags[tagindex][0] == 'FLExpronounceformat' \
				or allTags[tagindex][0] == 'FLExformformat':
			tagoutput += '\\charissil{'
		elif allTags[tagindex][0] == 'FLExform':
			tagoutput += '\\FLExformWSwrapper{\\FLExformWSformat{'
		elif allTags[tagindex][0] == 'FLExgloss':
			tagoutput += '\\FLExglossWSwrapper{\\FLExglossWSformat{'
		elif allTags[tagindex][0] == 'FLExformWSwrapper' \
				or allTags[tagindex][0] == 'FLExglossWSwrapper' \
				or allTags[tagindex][0] == 'FLExdefinitionWSwrapper':
			tagoutput += '('
		elif allTags[tagindex][0] == 'FLExsenses':
			tagoutput += '\\begin{enumerate}[noitemsep,leftmargin=!,labelindent=1.0cm,topsep=0pt,partopsep=0pt]'
		elif allTags[tagindex][0] == 'FLExsenseitem':
			tagoutput += '\\item '#extra space is necessary!!
		elif allTags[tagindex][0] == 'FLExgrammaticalinfo':
			tagoutput += '\\textbf{'
		elif allTags[tagindex][0] == 'FLExcomponentformindex':
			tagoutput += '\\textsubscript{'
		elif allTags[tagindex][0] == 'FLExcomponent':
			tagoutput += '\\FLExcomponentformwrapper{\\FLExcomponenformformat{'
		elif allTags[tagindex][0] == 'FLExdefinition':
			tagoutput += '\\FLExdefinitionWSwrapper{\\FLExdefinitionWSformat{'
		
		tagoutput += '#' + str(index+1)
		
		if allTags[tagindex][0] == 'FLExheadword' \
			or allTags[tagindex][0] == 'FLExheadwordformat' \
			or allTags[tagindex][0] == 'FLExheadwordWSformat' \
			or allTags[tagindex][0] == 'FLExformformat' \
			or allTags[tagindex][0] == 'FLExformWSformat' \
			or allTags[tagindex][0] == 'FLExpronounceformat' \
			or allTags[tagindex][0] == 'FLExcomponentformindex' \
			or allTags[tagindex][0] == 'FLExglossWSformat' \
			or allTags[tagindex][0] == 'FLExdefinitionWSformat' \
			or allTags[tagindex][0] == 'FLExformWSformat':
			tagoutput += '}'
		elif allTags[tagindex][0] == 'FLExformWSwrapper' \
				or allTags[tagindex][0] == 'FLExglossWSwrapper' \
				or allTags[tagindex][0] == 'FLExdefinitionWSwrapper':
			tagoutput += ')'
		elif allTags[tagindex][0] == 'FLExpronouncewrapper':
			tagoutput += '/}'
		elif allTags[tagindex][0] == 'FLExgrammaticalinfo':
			tagoutput += '}\\quad'
		elif allTags[tagindex][0] == 'FLExpronunciation' \
				or allTags[tagindex][0] == 'FLExform' \
				or allTags[tagindex][0] == 'FLExgloss' \
				or allTags[tagindex][0] == 'FLExcomponent' \
				or allTags[tagindex][0] == 'FLExdefinition':
			tagoutput += '}}'
		elif allTags[tagindex][0] == 'FLExsenses':
			tagoutput += '\\end{enumerate}~\\par'
		if allTags[tagindex][0] == 'FLExentry':
			tagoutput += '\\par'
		#=================================================================
	
		tagoutput += '}%% ' + arg
	
	tagoutput += ' \n\n'
	defsfile.write(tagoutput)

defsfile.close()

# Did the user pick a custom defs file? If so, let's use that one but keep our alt handy.
if defsfileusr :
    shutil.move(os.path.join(newpath, defsfilename), os.path.join(newpath, defsfilealtname))
    shutil.copyfile(os.path.join(defsfileusr), os.path.join(newpath, defsfilename))


outfile.close()
